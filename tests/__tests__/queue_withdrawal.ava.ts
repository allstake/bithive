import { fastForward, viewAccount } from "./helpers/btc_client";
import { initUnit } from "./helpers/context";
import { TestTransactionBuilder } from "./helpers/txn_builder";
import { assertFailure, daysToMs } from "./helpers/utils";

const test = initUnit();

async function makeDeposit(t: any, inputTxIndex = 0) {
  const { contract, alice } = t.context.accounts;
  const allstakePubkey = t.context.allstakePubkey;
  // real user pubkey from unisat
  const userPubkey = t.context.unisatPubkey;
  const builder = new TestTransactionBuilder(contract, alice, {
    userPubkey,
    allstakePubkey,
    inputTxIndex,
  });
  await builder.submit();

  return {
    builder,
    contract,
  };
}

test("queue withdraw with invalid signature", async (t) => {
  const { builder } = await makeDeposit(t);
  // this signature is generated by another keypair
  const sig =
    "1f4fed60394166af0c619a54bf9b1f62b4523679be1a844c81d58766569d40985725687ae8180757a084dabef526938ad47e7a81cbf58d0c3487170edf94c9b236";
  await assertFailure(
    t,
    builder.queueWithdraw(1, sig),
    "Invalid bitcoin signature",
  );
});

test("valid queue withdraw", async (t) => {
  const { builder, contract } = await makeDeposit(t);

  const sig = t.context.unisatSig;
  await builder.queueWithdraw(100, sig);

  const account = await viewAccount(contract, builder.userPubkeyHex);
  t.is(account.queue_withdrawal_amount, 100);
  t.is(account.queue_withdrawal_start_ts, daysToMs(3));
  t.is(account.nonce, 1);
  t.is(account.pending_withdraw_tx_id, null);
  t.is(account.pending_withdraw_unsigned_count, 0);
});

test("queue withdraw with wrong amount in signature", async (t) => {
  const { builder } = await makeDeposit(t);
  // signature of msg: "bithive.withdraw:0:1000sats"
  const sig =
    "2014bdfc6ea8174dd906b41fa3eaa7f9753d6633cc9bef5ae2edcf77cf1eb939c93b720fc8cb6a4aca08ce561eb6c3ce79e420bb662139f4190400f956e3caadaa";
  await assertFailure(
    t,
    builder.queueWithdraw(100, sig),
    "Invalid bitcoin signature",
  );
});

test("queue withdraw with wrong nonce (reuse signature)", async (t) => {
  const { builder } = await makeDeposit(t);
  const sig = t.context.unisatSig;
  await builder.queueWithdraw(100, sig);

  await assertFailure(
    t,
    builder.queueWithdraw(100, sig),
    "Invalid bitcoin signature",
  );
});

test("queue withdraw with bad amount", async (t) => {
  const { builder } = await makeDeposit(t);
  // signature of msg: "bithive.withdraw:0:200000000sats"
  const sig =
    "20b56c36a8cc07ccda98853817f0265f6fee33aac536edf5e5f47583e6e149eb7d3f63800782f5cd07464d97bcdaf7b5e57839a440eebc1aa33665f1ceea872ba2";

  await assertFailure(
    t,
    builder.queueWithdraw(2e8, sig),
    " Invalid queue withdrawal amount",
  );
});

test("queue withdraw again after deposit", async (t) => {
  const { builder, contract } = await makeDeposit(t);
  const sig = t.context.unisatSig;
  await builder.queueWithdraw(100, sig);

  // make another deposit, which makes the total deposit to 2 BTC
  await makeDeposit(t, 1);

  await fastForward(contract, daysToMs(1));

  // queue withdraw again
  // signature of msg: "bithive.withdraw:1:100000000sats"
  const sig2 =
    "20f7187a89e1e91d9fadbb44cecf4e247782ae5d81a5cb6f084c6d76823c1d5fca75ad6cafeb10995ff30082ad1b174d06fce8603a2ab1b9d8c0a5a41f40aa7749";
  await builder.queueWithdraw(1e8, sig2);

  const account = await viewAccount(contract, builder.userPubkeyHex);
  t.is(account.queue_withdrawal_amount, 1e8 + 100);
  t.is(account.queue_withdrawal_start_ts, daysToMs(4));
});
